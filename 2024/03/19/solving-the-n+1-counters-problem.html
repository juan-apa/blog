<!DOCTYPE html>
<html lang="en-US" class="dark">
  <head>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta charset="utf-8">
    <title>Solving The N+1 Counters Problem - Juan Aparicio</title>
    <link rel="stylesheet" href="/assets/css/main.css">
    <link rel="stylesheet" href="/assets/css/syntax-highlight.css">

    <link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro:wght@400;600;700&display=swap" rel="stylesheet">


    <link rel="favicon" href="/assets/images/favicon.ico">
<link rel="apple-touch-icon" sizes="180x180" href="/assets/images/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/assets/images/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/assets/images/favicon-16x16.png">
<link rel="manifest" href="/assets/site.webmanifest">

    <meta property="og:title" content="Solving The N+1 Counters Problem" />
<meta property="og:description" content="A Ruby and Rails developer's blog" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://juan-apa.xyz/2024/03/19/solving-the-n+1-counters-problem.html" />

    <meta property='og:image' content='https://juan-apa.xyz/assets/og_images/2024-03-19-solving-the-n+1-counters-problem.png' />
  </head>
  <body class="dark:bg-neutral-800 dark:text-gray-100 bg-white text-gray-950 max-w-2xl m-auto font-mono min-h-screen flex flex-col">
    <nav class="">
  <ul class="flex p-4 h-full">
    <li><a href="/" class="text-lg font-bold hover:dark:bg-neutral-700 px-4 py-2">Juan Aparicio</a></li>
    <li class="grow"></li>
    <li><a href="/blog" class="text-lg font-bold hover:dark:bg-neutral-700 px-4 py-2 underline underline-neutral-200">Blog</a></li>
  </ul>
</nav>


    <header class="flex flex-col items-center justify-center py-16">
      <h1 class="text-4xl font-bold text-center">Solving The N+1 Counters Problem</h1>
      
        <p class="text-neutral-500 text-lg mt-2">March 19, 2024</p>
      
    </header>


    <div class="container mx-auto prose dark:prose-invert dark:text-gray-100 text-gray-950 pt-4 px-2 sm:px-0">
      <p>The N+1 problem is a common performance issue that’s present in most rails apps I’ve worked in. It occurs when listing a collection of objects and, for each object, fetching associations from the database is required.</p>

<p>In this post, I’ll focus on a specific variation: displaying the count of associated objects.</p>

<h2 id="the-problem">The Problem</h2>
<p>Consider having a <code class="language-plaintext highlighter-rouge">User</code> model and a <code class="language-plaintext highlighter-rouge">Post</code> model, where a <code class="language-plaintext highlighter-rouge">User</code> has many <code class="language-plaintext highlighter-rouge">Post</code>s. The goal is to display the number of posts each user has in a list of users.</p>

<div class="language-ruby not-prose highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># app/models/user.rb</span>
<span class="k">class</span> <span class="nc">User</span> <span class="o">&lt;</span> <span class="no">ApplicationRecord</span>
  <span class="n">has_many</span> <span class="ss">:posts</span>
<span class="k">end</span>

<span class="c1"># app/models/post.rb</span>
<span class="k">class</span> <span class="nc">Post</span> <span class="o">&lt;</span> <span class="no">ApplicationRecord</span>
  <span class="n">belongs_to</span> <span class="ss">:user</span>
<span class="k">end</span>

<span class="c1"># app/controllers/users_controller.rb</span>
<span class="k">class</span> <span class="nc">UsersController</span> <span class="o">&lt;</span> <span class="no">ApplicationController</span>
  <span class="k">def</span> <span class="nf">index</span>
    <span class="vi">@users</span> <span class="o">=</span> <span class="no">User</span><span class="p">.</span><span class="nf">all</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<div class="language-erb not-prose highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">&lt;!-- app/views/users/index.html.erb --&gt;</span>
<span class="cp">&lt;%</span> <span class="vi">@users</span><span class="p">.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">user</span><span class="o">|</span> <span class="cp">%&gt;</span>
  <span class="nt">&lt;p&gt;</span><span class="cp">&lt;%=</span> <span class="n">user</span><span class="p">.</span><span class="nf">name</span> <span class="cp">%&gt;</span>, <span class="cp">&lt;%=</span> <span class="n">user</span><span class="p">.</span><span class="nf">posts</span><span class="p">.</span><span class="nf">count</span> <span class="cp">%&gt;</span> posts<span class="nt">&lt;/p&gt;</span>
<span class="cp">&lt;%</span> <span class="k">end</span> <span class="cp">%&gt;</span>
</code></pre></div></div>

<h2 id="solving-with-counter-caches">Solving with counter caches</h2>
<p>Rails’ <code class="language-plaintext highlighter-rouge">counter_cache</code> feature is a straightforward solution for storing a running count of posts for each user, eliminating the need to query the database for this information.</p>

<div class="language-ruby not-prose highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># app/models/post.rb</span>
<span class="k">class</span> <span class="nc">Post</span> <span class="o">&lt;</span> <span class="no">ApplicationRecord</span>
  <span class="n">belongs_to</span> <span class="ss">:user</span><span class="p">,</span> <span class="ss">counter_cache: </span><span class="kp">true</span>
<span class="k">end</span>
</code></pre></div></div>

<div class="language-erb not-prose highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">&lt;!-- app/views/users/index.html.erb --&gt;</span>
<span class="cp">&lt;%</span> <span class="vi">@users</span><span class="p">.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">user</span><span class="o">|</span> <span class="cp">%&gt;</span>
  <span class="nt">&lt;p&gt;</span><span class="cp">&lt;%=</span> <span class="n">user</span><span class="p">.</span><span class="nf">name</span> <span class="cp">%&gt;</span>, <span class="cp">&lt;%=</span> <span class="n">user</span><span class="p">.</span><span class="nf">posts_count</span> <span class="cp">%&gt;</span> posts<span class="nt">&lt;/p&gt;</span>
<span class="cp">&lt;%</span> <span class="k">end</span> <span class="cp">%&gt;</span>
</code></pre></div></div>
<h3 id="how-this-works">How this works</h3>
<ol>
  <li>Add a <code class="language-plaintext highlighter-rouge">posts_count</code> column to the <code class="language-plaintext highlighter-rouge">users</code> table.</li>
  <li>Add the <code class="language-plaintext highlighter-rouge">counter_cache: true</code> option to the <code class="language-plaintext highlighter-rouge">belongs_to</code> association in the <code class="language-plaintext highlighter-rouge">Post</code> model.</li>
  <li>Rails will automatically update the <code class="language-plaintext highlighter-rouge">posts_count</code> column in the <code class="language-plaintext highlighter-rouge">users</code> table when posts are created, updated, or destroyed.</li>
</ol>

<p>This method is often the first solution considered for addressing this issue.</p>

<h3 id="the-problem-with-counter-caches">The problem with counter caches</h3>
<p>While counter caches are effective in many scenarios, they have limitations, such as:</p>
<ul>
  <li>Difficulty filtering the count of associated objects.</li>
  <li>Challenges updating records in bulk without triggering callbacks. (remember, <code class="language-plaintext highlighter-rouge">counter_cache</code> uses a callback in the model to update the count)</li>
  <li>The potential need for manual count updates due to the above issues.</li>
</ul>

<h2 id="solving-with-includes-and-size">Solving with <code class="language-plaintext highlighter-rouge">includes</code> and <code class="language-plaintext highlighter-rouge">size</code></h2>
<p>An alternative solution involves using <code class="language-plaintext highlighter-rouge">includes</code> to eager load associated objects and then counting them in memory with the <code class="language-plaintext highlighter-rouge">size</code> method.</p>

<div class="language-ruby not-prose highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">User</span> <span class="o">&lt;</span> <span class="no">ApplicationRecord</span>
  <span class="n">has_many</span> <span class="ss">:posts</span>

  <span class="n">delegate</span> <span class="ss">:size</span><span class="p">,</span> <span class="ss">to: :posts</span><span class="p">,</span> <span class="ss">prefix: </span><span class="kp">true</span>
<span class="k">end</span>

<span class="c1"># app/controllers/users_controller.rb</span>
<span class="k">class</span> <span class="nc">UsersController</span> <span class="o">&lt;</span> <span class="no">ApplicationController</span>
  <span class="k">def</span> <span class="nf">index</span>
    <span class="vi">@users</span> <span class="o">=</span> <span class="no">User</span><span class="p">.</span><span class="nf">includes</span><span class="p">(</span><span class="ss">:posts</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<div class="language-erb not-prose highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">&lt;!-- app/views/users/index.html.erb --&gt;</span>
<span class="cp">&lt;%</span> <span class="vi">@users</span><span class="p">.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">user</span><span class="o">|</span> <span class="cp">%&gt;</span>
  <span class="nt">&lt;p&gt;</span><span class="cp">&lt;%=</span> <span class="n">user</span><span class="p">.</span><span class="nf">name</span> <span class="cp">%&gt;</span>, <span class="cp">&lt;%=</span> <span class="n">user</span><span class="p">.</span><span class="nf">posts_size</span> <span class="cp">%&gt;</span> posts<span class="nt">&lt;/p&gt;</span>
<span class="cp">&lt;%</span> <span class="k">end</span> <span class="cp">%&gt;</span>
</code></pre></div></div>

<h3 id="how-this-works-1">How this works</h3>
<ol>
  <li>Eager load the posts for each user.</li>
  <li>Use the <code class="language-plaintext highlighter-rouge">delegate</code> method to create a <code class="language-plaintext highlighter-rouge">posts_size</code> method that returns the count of posts for each user.</li>
  <li>Use the <code class="language-plaintext highlighter-rouge">posts_size</code> method in the view to display the count.</li>
</ol>

<p>This solution is great because it doesn’t require any extra database columns, and it’s more flexible than <code class="language-plaintext highlighter-rouge">counter_cache</code>. But it has a downside: it’s not as performant as <code class="language-plaintext highlighter-rouge">counter_cache</code> because it needs to load all the associated objects into memory.</p>

<h3 id="the-problem-with-includes-and-size">The problem with <code class="language-plaintext highlighter-rouge">includes</code> and <code class="language-plaintext highlighter-rouge">size</code></h3>
<p>The potential downside of this approach, is when there are many associated records, which leads to a large amount of data being loaded into memory.</p>

<h2 id="solving-the-filtered-counter-problem">Solving the filtered counter problem</h2>
<p>For situations where <code class="language-plaintext highlighter-rouge">counter_cache</code> falls short, such as needing to filter counts of associated objects, the <code class="language-plaintext highlighter-rouge">counter_culture</code> gem offers a robust solution. However, embracing simplicity and minimizing dependencies is a valuable strategy. A Rails-centric approach can be just as effective</p>

<p class="prose-card"><a href="https://github.com/magnusvk/counter_culture">counter_culture</a> solves this problem really well. It provides a <code class="language-plaintext highlighter-rouge">counter_culture</code> method that takes a block to define the conditions for the counter. It also provides a <code class="language-plaintext highlighter-rouge">reset_counters</code> method to update the counters in bulk without triggering callbacks.</p>

<p>After re-reading the rails <code class="language-plaintext highlighter-rouge">ActiveRecord</code> documentation, I figured, that solving this is also dead-simple:</p>

<div class="language-ruby not-prose highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">User</span> <span class="o">&lt;</span> <span class="no">ApplicationRecord</span>
  <span class="n">has_many</span> <span class="ss">:posts</span>
  <span class="n">has_many</span> <span class="ss">:published_posts</span><span class="p">,</span> <span class="o">-&gt;</span> <span class="p">{</span> <span class="n">where</span><span class="p">.</span><span class="nf">not</span><span class="p">(</span><span class="ss">published_at: </span><span class="kp">nil</span><span class="p">)</span> <span class="p">},</span> <span class="ss">class_name: </span><span class="s1">'Post'</span>

  <span class="n">delegate</span> <span class="ss">:size</span><span class="p">,</span> <span class="ss">to: :posts</span><span class="p">,</span> <span class="ss">prefix: </span><span class="kp">true</span>
  <span class="n">delegate</span> <span class="ss">:size</span><span class="p">,</span> <span class="ss">to: :published_posts</span><span class="p">,</span> <span class="ss">prefix: </span><span class="kp">true</span>
<span class="k">end</span>

<span class="c1"># app/controllers/users_controller.rb</span>
<span class="k">class</span> <span class="nc">UsersController</span> <span class="o">&lt;</span> <span class="no">ApplicationController</span>
  <span class="k">def</span> <span class="nf">index</span>
    <span class="vi">@users</span> <span class="o">=</span> <span class="no">User</span><span class="p">.</span><span class="nf">all</span><span class="p">.</span><span class="nf">includes</span><span class="p">(</span><span class="ss">:posts</span><span class="p">,</span> <span class="ss">:published_posts</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<div class="language-erb not-prose highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">&lt;!-- app/views/users/index.html.erb --&gt;</span>
<span class="cp">&lt;%</span> <span class="vi">@users</span><span class="p">.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">user</span><span class="o">|</span> <span class="cp">%&gt;</span>
  <span class="nt">&lt;p&gt;</span><span class="cp">&lt;%=</span> <span class="n">user</span><span class="p">.</span><span class="nf">name</span> <span class="cp">%&gt;</span>, <span class="cp">&lt;%=</span> <span class="n">user</span><span class="p">.</span><span class="nf">posts_size</span> <span class="cp">%&gt;</span> posts, <span class="cp">&lt;%=</span> <span class="n">user</span><span class="p">.</span><span class="nf">published_posts_size</span> <span class="cp">%&gt;</span> published posts<span class="nt">&lt;/p&gt;</span>
<span class="cp">&lt;%</span> <span class="k">end</span> <span class="cp">%&gt;</span>
</code></pre></div></div>

<h3 id="how-this-works-2">How this works</h3>
<ol>
  <li>Define a new association called <code class="language-plaintext highlighter-rouge">published_posts</code> that filters the posts that have a <code class="language-plaintext highlighter-rouge">published_at</code> date.</li>
  <li>Use the <code class="language-plaintext highlighter-rouge">delegate</code> method to create a <code class="language-plaintext highlighter-rouge">published_posts_size</code> method that returns the count of published posts for each user.</li>
  <li>Use the <code class="language-plaintext highlighter-rouge">published_posts_count</code> method in the view to display the count.</li>
</ol>

<h3 id="why-is-this-not-triggering-n1-queries">Why is this not triggering N+1 queries?</h3>
<p>Well, for a long time, I had a misconception about <code class="language-plaintext highlighter-rouge">size</code> method in <code class="language-plaintext highlighter-rouge">ActiveRecord::Relation</code>. I thought that calling <code class="language-plaintext highlighter-rouge">size</code> on an association would always load the associated objects into memory and count them there everytime.</p>

<p>However, this is not the case. When you call <code class="language-plaintext highlighter-rouge">size</code> on an association, it will check if the association has already been loaded into memory (in this case, by the <code class="language-plaintext highlighter-rouge">includes</code> method), and if it has, it will count the elements in memory. If it hasn’t, it will execute a <code class="language-plaintext highlighter-rouge">SELECT COUNT(*) ...</code> query to the database.</p>

<p>So, in this case, the code is not triggering N+1 queries because the associated objects are eager-loaded into memory with <code class="language-plaintext highlighter-rouge">includes(:posts, :published_posts)</code>.</p>

<h2 id="conclusion">Conclusion</h2>
<p>The N+1 counters problem is a common issue when working with associations in rails. There are different solutions to the problem, and the best one depends on the specific requirements of your application.</p>

<ul>
  <li>
    <p><code class="language-plaintext highlighter-rouge">counter_cache</code> is the go-to solution for the problem, but it has some limitations. Also, if you need to filter the count of associated objects or update records in bulk without triggering callbacks, it may not be the best solution.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">counter_culture</code> gem is a great solution for the filtered counter problem, but it adds a dependency to your project, and also it will still be affected by the callback limitations.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">includes</code> + <code class="language-plaintext highlighter-rouge">size</code> is a great solution for the problem, but it’s not as performant as <code class="language-plaintext highlighter-rouge">counter_cache</code> (for reads!) because it needs to load all the associated objects into memory. If your collection is small, this is not a problem.</p>
  </li>
</ul>

<p>Maybe try to keep things simple in the beginning, use the tools that Rails provides, like counter_cache or includes + size. You can always refactor later if the need arises. Don’t overcomplicate things from the start.</p>

    </div>

    <footer class="p-4 text-sm text-center mt-auto">
  <ul class="flex justify-center gap-x-2">
    <li class="">
      <a href="https://twitter.com/not_kombustor" class="">Twitter (<span class="border-b border-solid border-neutral-200">@not_kombustor</span>)</a>
    </li>
    <vl class="border-r-2 dark:border-gray-700 border-gray-200"></vl>
    <li class="">
      <a href="https://github.com/juan-apa" class="">GitHub (<span class="border-b border-solid border-neutral-200">@juan-apa</span>)</a>
    </li>
  </ul>
</footer>

  </body>
</html>
